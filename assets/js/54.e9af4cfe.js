(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{1193:function(r,t,_){"use strict";_.r(t);var v=_(0),s=Object(v.a)({},(function(){var r=this,t=r.$createElement,v=r._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[v("h2",{attrs:{id:"引言"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#引言"}},[r._v("#")]),r._v(" 引言")]),r._v(" "),v("blockquote",[v("p",[r._v("IP+MAC+port 标识一个全世界范围内独一无二的基于网络通信的软件.."),v("br"),r._v("\n参考链接: "),v("code",[r._v("https://mp.weixin.qq.com/s/Uf42QEL6WUSHOwJ403FwOA")])])]),r._v(" "),v("p",[v("font",{attrs:{color:"purple"}},[r._v("[传输层的由来] ")]),v("br"),r._v("\n       网络层的IP地址帮我们区分子网,以太网层的MAC帮我们找到主机.."),v("br"),r._v("\n       我们通过IP和MAC找到了一台特定的主机,那如何标识这台主机上特定的应用程序? 答案就是端口.."),v("br"),r._v("\n       端口即应用程序与网卡关联的编号...")],1),r._v(" "),v("p",[v("font",{attrs:{color:"purple"}},[r._v("[传输层功能]")]),v("br"),r._v("\n       建立 "),v("strong",[r._v("端")]),r._v(" 口到 "),v("strong",[r._v("端")]),r._v(" 口的通信"),v("br"),r._v(" "),v("font",{attrs:{color:"gray"}},[v("strong",[r._v("端口范围0-65535")]),r._v(", 0-1023为系统占用端口,端口占用的是操作系统的资源")]),v("br"),r._v(" "),v("font",{attrs:{color:"gray"}},[r._v("端口打个比方就是操作系统开的一个个的小窗口,应用软件数据通过这些小窗口再到网卡.")])],1),r._v(" "),v("p",[v("font",{attrs:{color:"purple"}},[r._v("[传输层的数据]")]),v("br"),r._v("\n       1> 依照tcp&udp协议在传输层的构建的数据,称为"),v("font",{attrs:{color:"brown"}},[v("strong",[r._v("'数据段'")])]),v("br"),r._v("\n       2> 数据段 = head + data"),v("br"),r._v(" "),v("strong",[r._v("head")]),r._v(" 里放 "),v("strong",[r._v("<源端口>")]),r._v(" 和 "),v("strong",[r._v("<目标端口>")]),v("br"),r._v(" "),v("font",{attrs:{color:"gray"}},[r._v("端口在本机唯一即可!")])],1),r._v(" "),v("hr"),r._v(" "),v("h2",{attrs:{id:"udp-协议"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#udp-协议"}},[r._v("#")]),r._v(" UDP 协议")]),r._v(" "),v("blockquote",[v("p",[r._v("UDP协议 -- 无连接、不可靠的用户报文协议.."),v("br"),r._v("\n在发送数据时,不需要建立连接,拿到IP和端口直接发过去了..发完后数据就删掉了.")]),r._v(" "),v("p",[v("strong",[r._v("应用场景:")]),r._v("  查询类的操作(eg dhcp查询)  集群的时间同步 QQ聊天")])]),r._v(" "),v("p",[v("strong",[r._v("Q:")]),r._v(" 前三层协议只能把数据包从一个主机搬到另外一台主机,但是,到了目的地以后,"),v("br"),r._v("\n     数据包具体交给哪个程序(进程)呢？"),v("br"),r._v(" "),v("strong",[r._v("A:")]),r._v(" 需要把通信的进程区分开来,于是就给每个进程分配一个数字编号: "),v("font",{attrs:{color:"blue"}},[r._v("端口号")])],1),r._v(" "),v("p",[r._v("So,现目前,经过前四层(传输层～数据链路层 从上到下),应用数据被封装成了这样:"),v("br"),r._v(" "),v("font",{attrs:{color:"gray"}},[r._v("数据链路层头部        网络层头部    传输层头部         数据部分")]),v("br"),r._v(" "),v("font",{attrs:{color:"gray"}},[v("strong",[r._v("源MAC 目的MAC    源IP 目的IP    源端口号 目的端口号    数据部分")])]),v("br"),r._v(" "),v("font",{attrs:{color:"blue"}},[r._v("这样子,我们将主机到主机的通信,升级成了进程和进程之间的通信..")])],1),r._v(" "),v("p",[r._v("经过上述的过程,我们在不知不觉中就已经实现了"),v("strong",[r._v("UDP 协议")]),r._v("！"),v("br"),r._v(" "),v("font",{attrs:{color:"gray"}},[r._v("(当然 UDP 协议中不光有源端口和目标端口,还有数据包长度和校验值,我们暂且略过)")])],1),r._v(" "),v("p",[v("img",{attrs:{src:_(468),alt:""}})]),r._v(" "),v("p",[v("strong",[r._v("[引出TCP协议]")]),v("br"),r._v("\n用UDP协议A同B能实现通信,但这个通信过程中存在很多问题!!!没有那么简单!!"),v("br"),r._v(" "),v("font",{attrs:{color:"brown"}},[v("strong",[r._v("丢包问题、效率问题、顺序问题、流量问题、拥塞问题、连接问题...")])]),r._v(" 这些问题TCP协议才能解决!!!")],1),r._v(" "),v("hr"),r._v(" "),v("h2",{attrs:{id:"tcp协议"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp协议"}},[r._v("#")]),r._v(" TCP协议")]),r._v(" "),v("blockquote",[v("p",[r._v("TCP协议 --  面向连接的、可靠的、基于字节流的传输控制协议  netstat -an")]),r._v(" "),v("p",[v("strong",[r._v("应用场景:")]),r._v(" 与用户打交道的应用程序")])]),r._v(" "),v("p",[v("img",{attrs:{src:_(469),alt:""}})]),r._v(" "),v("h3",{attrs:{id:"可靠交互"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#可靠交互"}},[r._v("#")]),r._v(" 可靠交互")]),r._v(" "),v("h5",{attrs:{id:"☆-丢包问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#☆-丢包问题"}},[r._v("#")]),r._v(" ☆ [丢包问题]")]),r._v(" "),v("blockquote",[v("p",[r._v("由于网络的不可靠,A传给B的数据包可能在半路丢失.."),v("br"),r._v("\n不难想到,对于丢包问题,B应该告诉A数据包没收到,A再重;或者B告诉A一声数据包收到了.")])]),r._v(" "),v("p",[v("font",{attrs:{color:"brown"}},[r._v("停止等待协议")]),v("br"),r._v(" "),v("font",{attrs:{color:"gray"}},[r._v("A每发一个包,都必须收到来自B的确认("),v("strong",[r._v("回一个ACK包")]),r._v(")后,再发下一个;")]),v("br"),r._v(" "),v("font",{attrs:{color:"gray"}},[r._v("否则在一定时间内没有收到确认,就重传这个包.")])],1),r._v(" "),v("p",[r._v("     这样以来,TCP协议的通信过程有了一个新特征 -- "),v("font",{attrs:{color:"red"}},[r._v("可靠交互")]),r._v(".")],1),r._v(" "),v("h5",{attrs:{id:"☆-效率问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#☆-效率问题"}},[r._v("#")]),r._v(" ☆ [效率问题]")]),r._v(" "),v("blockquote",[v("p",[r._v("停止等待解决了丢包问题,可靠是可靠,但效率太慢了..")])]),r._v(" "),v("p",[r._v("于是乎,我们提出假设,用 "),v("font",{attrs:{color:"brown"}},[r._v("流水线")]),r._v(" 的形式,A连续发几个数据包给B,B再按收到的顺序依次ACK确认.."),v("br"),r._v(" "),v("font",{attrs:{color:"gray"}},[r._v("(前提,A发出去的包按照发送的先后依次到达B,才能保证B依次回应的ACK对应的上..)")])],1),r._v(" "),v("p",[r._v("看似成立,但实则傻白甜了.网络是复杂的,不可靠的."),v("br"),r._v(" "),v("font",{attrs:{color:"brown"}},[r._v("A发出去的数据包,可是会走 "),v("em",[r._v("不同的路径")]),r._v(" (耗时不同) 到达B.")]),v("br"),r._v(" "),v("font",{attrs:{color:"gray"}},[r._v("这可能会导致出现这种情况,第2个发出去的包会在第5个发出去的包到达B后才到达B..")])],1),r._v(" "),v("p",[r._v("也就是说,在流水线中有多个数据包和ACK包在乱序流动,他们之间对应关系乱掉啦!!")]),r._v(" "),v("h5",{attrs:{id:"☆-顺序问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#☆-顺序问题"}},[r._v("#")]),r._v(" ☆ [顺序问题]")]),r._v(" "),v("blockquote",[v("p",[r._v("A在发送的数据包中增加一个"),v("strong",[r._v("序号(seq),")]),r._v(" 同时B要在"),v("strong",[r._v("ACK包")]),r._v(" 上增加一个 "),v("strong",[r._v("确认号(ack)")]),r._v("."),v("br"),r._v("\n这样不但解决了停止等待协议的效率问题,也通过标序号的方式解决了顺序问题.")])]),r._v(" "),v("p",[r._v("现实中,为了减少网络IO,B会采用 "),v("font",{attrs:{color:"brown"}},[r._v("累计确认/累计应答")]),r._v(" 的方式给A回复确认号(ack).")],1),r._v(" "),v("p",[r._v("举个栗子:"),v("br"),r._v("\n     A连续发送了带有1,2,3序号(seq)的数据包给B,"),v("br"),r._v("\n     B收到了这三个数据包,将回应了一个带有确认号(ack=4)的ACK包给A;"),v("br"),r._v(" "),v("font",{attrs:{color:"lightblue"}},[v("strong",[r._v("代表A发送的序号小于4的数据包都收到了..也同时告诉A下一个数据包应该发的序号是4.")])])],1),r._v(" "),v("p",[v("img",{attrs:{src:_(470),alt:""}})]),r._v(" "),v("p",[v("font",{attrs:{color:"gray"}},[r._v("Ps: ack号是收到的最后一个数据包的序号seq+1. So,纠正下,下图中B回复A的ACK包的确认号应该为4..")])],1),r._v(" "),v("h3",{attrs:{id:"滑动窗口机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#滑动窗口机制"}},[r._v("#")]),r._v(" 滑动窗口机制")]),r._v(" "),v("blockquote",[v("p",[r._v("TCP可靠传输的实现依托于 -- 以字节为单位的滑动窗口"),v("br"),r._v("\n视频链接: "),v("code",[r._v("https://www.bilibili.com/video/BV194411h71z")]),r._v("!!!!!!")])]),r._v(" "),v("p",[v("img",{attrs:{src:_(471),alt:""}})]),r._v(" "),v("p",[v("font",{attrs:{color:"gray"}},[r._v("Ps: 图中一个个小框代表一个个字节, 收到的最后一个确认号是3.. 窗口上边界指的是滑动窗口的前沿.")])],1),r._v(" "),v("h3",{attrs:{id:"三次握手"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#三次握手"}},[r._v("#")]),r._v(" 三次握手")]),r._v(" "),v("blockquote",[v("p",[r._v("三次握手 --  准确点应该是三报文握手,即一次握手过程中交换了三个报文,并不是进行了三次握手!")]),r._v(" "),v("p",[v("strong",[r._v("TCP通信之前必须建立双向通路")]),r._v(", 这个连接是虚拟的, 是由 A 和 B 共同维护的, 在网络中的设备根本就不知道连接这回事儿！")]),r._v(" "),v("p",[v("strong",[r._v('TCP协议在 "通信之前" 必须建立双向连接')]),r._v(" ,通常都是客户端主动连接服务端, 所以必须先启动服务端."),v("br"),r._v("\nPs:UDP协议不需要先启动服务端.")])]),r._v(" "),v("p",[v("font",{attrs:{color:"gray"}},[v("strong",[r._v("客户端")]),r._v(": 主动发起连接建立的应用进程")]),v("br"),r._v(" "),v("font",{attrs:{color:"gray"}},[v("strong",[r._v("服务端")]),r._v(": 被动等待连接建立的应用进程")])],1),r._v(" "),v("p",[v("img",{attrs:{src:_(472),alt:""}})]),r._v(" "),v("p",[v("font",{attrs:{color:"gray"}},[r._v("Ps: 两条线是时间线! 代表客户端和服务端建好连接需要花费的时间..")])],1),r._v(" "),v("h5",{attrs:{id:"☆-说明"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#☆-说明"}},[r._v("#")]),r._v(" ☆ [说明]")]),r._v(" "),v("p",[r._v("结合前面的TCP协议的组成图."),v("br"),r._v(" "),v("strong",[r._v("SYN")]),r._v(" --  同步位,表明发送的是连接请求报文段"),v("br"),r._v(" "),v("strong",[r._v("ACK")]),r._v(" --  确认位,表明发送的是连接确认报文段"),v("br"),r._v(" "),v("strong",[r._v("seq")]),r._v(" --  序号. TCP是面向字节流的,在TCP连接中传送的字节流的每一个字节都按顺序编号"),v("br"),r._v(" "),v("strong",[r._v("ack")]),r._v(" --  确认号,是期望收到对方下一个报文段的第一个数据字节的序号")]),r._v(" "),v("h5",{attrs:{id:"☆-连接步骤"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#☆-连接步骤"}},[r._v("#")]),r._v(" ☆ [连接步骤]")]),r._v(" "),v("p",[r._v("1> 一开始,B会处于LISTEN(监听)状态,等待某些客户的连接请求."),v("br"),r._v("\n2> A发送完SYN连接报文段后,进入SYN-SENT(同步已发送)状态."),v("br"),r._v("\n3> B收到A发送的SYN后,若同意建立连接,会向A发送ACK确认报文段.进入SYN_RCVD(同步收到)状态."),v("br"),r._v("\n     只不过在这个确认报文段中,不仅将ACK置为1,还会将SYN置为1,相当于把向B发送连接请求的活一起干了.."),v("br"),r._v("\n     也可以简说发送的是ACK+SYN报文段.."),v("br"),r._v("\n     注意: "),v("code",[r._v("ack = x+1")]),r._v(" 表示B已经接收到A发送过来的序号为x的报文."),v("br"),r._v("\n4> A收到B的确认后,还要向B给出确认.A进入ESTAB_LISHED(已经建立连接)状态."),v("br"),r._v("\n     注意: 这里的"),v("code",[r._v("seq = x+1")]),r._v(",是因为A收到的B的确认报文中 "),v("code",[r._v("ack = x+1")]),v("br"),r._v("\n                -- 期望收到的下一个报文的序号是以x+1开始的."),v("br"),r._v("\n5> B收到A的确认后,B进入ESTAB_LISHED状态. "),v("strong",[r._v("此刻A与B的双向道路才真正的打通!")])]),r._v(" "),v("p",[r._v("注意哦! "),v("font",{attrs:{color:"gray"}},[v("strong",[r._v("SYN_RCVD")]),r._v(" 也叫做 "),v("strong",[r._v("半连接")]),r._v(" 状态")]),v("br"),r._v("\n敲黑板! "),v("font",{attrs:{color:"gray"}},[r._v("B向A发送的报文实际上可以拆成两个报文段,可以先发送一个确认报文段(ACK=1 ack=x+1),再发送一个同步报文段(SYN=1,seq=y). "),v("strong",[r._v("这样四报文握手的效果跟三报文握手的效果是一样的!")])])],1),r._v(" "),v("p",[v("font",{attrs:{color:"green"}},[r._v("Q:讲道理,A向B发送连接请求后,B同意了,那么AB之间的通路就建立了.那为什么A最后还要向B发送一次确认？")]),v("br"),r._v(" "),v("strong",[r._v("A:")]),r._v(" 假设A不发送最后那次请求.这是前提.A向B发送的连接请求因为网络原因未能及时到达B."),v("br"),r._v("\n     于是乎,A重新发送了一次连接请求,而后A收到了B的确认,连接建立."),v("br"),r._v("\n     AB之间数据传输完毕后,连接释放..好巧不巧,A向B发送的第一次连接请求并没有丢失,在连接释放后到达了B."),v("br"),r._v("\n     B就会认为A发送了一次新的连接请求.并一直等待A发来数据..B的许多资源就这样浪费掉了.."),v("br"),r._v("\n     A最后向B发送一次确认就能有效的避免这种情况!! client不会向server的确认发出确认. server由于收不到确认,就知道client并没有要求建立连接!!")],1),r._v(" "),v("h5",{attrs:{id:"☆-半连接池"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#☆-半连接池"}},[r._v("#")]),r._v(" ☆ [半连接池]")]),r._v(" "),v("blockquote",[v("p",[r._v("半连接池占用服务器固定内存的大小")])]),r._v(" "),v("p",[r._v("多个客户端同时向一个服务端发送SYN请求连接,这些连接到了服务端会先依次放到半连接池里面.."),v("br"),r._v(" "),v("strong",[r._v("在不断放的同时")]),r._v(", 服务器的操作系统会根据队列先进先出的原则 "),v("strong",[r._v("不断的取")]),r._v(" 半连接池里的请求..")]),r._v(" "),v("p",[r._v("在现实当中,打开某一个网页,若原地转圈,表示请求已经在半连接池里了,要等一小会;"),v("br"),r._v("\n若直接拒绝了请求,访问不上,则证明池子已经满了,请求在池子外面.."),v("br"),r._v("\n所以在高并发的场景下,我们会进行一个优化: 将半连接池增大."),v("br"),r._v("\n调多大没个标准,因为半连接池占用的内存空间变大了,相应的其他进程存取数据可用的空间就少了.."),v("br"),r._v(" "),v("font",{attrs:{color:"gray"}},[v("strong",[r._v("敲黑板!")]),r._v(" 最本质的优化,  "),v("em",[v("strong",[r._v("加内存条")])]),r._v(" 是软件优化的N倍.")])],1),r._v(" "),v("h5",{attrs:{id:"☆-syn洪水攻击"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#☆-syn洪水攻击"}},[r._v("#")]),r._v(" ☆ [syn洪水攻击]")]),r._v(" "),v("p",[r._v("服务器处于LISTEN和ESTABLISHED状态都是正常的,前者表示正在监听,后者表示服务器正在服务多个客户端."),v("br"),r._v("\n若发现服务器有大量客户端发来的请求连接处于SYN_RCVD状态,就不正常啦...表明操作系统忙不过来了."),v("br"),r._v(" "),v("strong",[r._v("why？因为连接建立是很快很快... 客户端的SYN_SENT状态和服务器的SYN_RCVD状态是很难捕捉的到.")])]),r._v(" "),v("p",[v("font",{attrs:{color:"green"}},[v("em",[r._v("syn洪水攻击就会造成服务器大量SYN_RCVD状态出现..")])]),r._v("\n它会模拟大量的假的客户端朝服务端发SYN连接请求,发完后客户端就消失了; 服务端收到后, "),v("strong",[r._v("TCP是好人协议嘛")]),r._v(" ,不会验证客户端的身份,会直接回复确认信息,但客户端已经消失了,是不会回复最后的确认的,但服务端不知道啊,服务端会每隔一段时间重复回一次,尝试几次后发现客户端还是没有回复最后的确认信息,那么服务端就会认为这是个客户端出现了什么异常...连接就取消啦. 但在这期间,要占用服务端的资源嘛..."),v("br"),r._v(" "),v("font",{attrs:{color:"gray"}},[r._v("也许你会说,TCP为啥不能验证身份后再开始建立连接呢？因为TCP是一个底层的协议,设计复杂一点,建立连接的速度就会降下来,整个互联网通信效率都会被拉下来.. 所以安全性的问题往往会在应用层,应用程序里解决..")])],1),r._v(" "),v("p",[r._v("再唠唠嗑,服务器通常存放在机房里,服务器外面是交换机,交换机外面是路由,再往外是各种网络设备.."),v("br"),r._v("\nsyn洪水攻击往往是外网攻击,攻击的流量若很大很大,还没到服务器就把外面的交换机给干趴下了..那么不管增大服务器的半连接池到多大,服务器的性能有多牛也没有用.."),v("br"),r._v("\n用正规的机房,使用阿里云腾讯云的服务器,它们会帮忙解决这个问题..")]),r._v(" "),v("h3",{attrs:{id:"四次挥手"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#四次挥手"}},[r._v("#")]),r._v(" 四次挥手")]),r._v(" "),v("blockquote",[v("p",[r._v("四报文握手.")])]),r._v(" "),v("p",[r._v("C与S谁先发完数据,谁就先主动发起断开连接.这里假设客户端A先发完数据"),v("br"),r._v(" "),v("font",{attrs:{color:"gray"}},[r._v("一台机器既是某个软件的客户端也运行着某个软件的服务端.所以在一台机器上可以同时看到C与S的状态.")])],1),r._v(" "),v("p",[v("img",{attrs:{src:_(473),alt:""}})]),r._v(" "),v("p",[r._v("1> A会向服务端B发送FIN连接释放报文段.A进入FIN_WAIT_1(终止等待1)状态,等待B的确认."),v("br"),r._v("\n2> B收到A发送来的FIN=1报文后,立即发送ACK确认报文.B进入CLOSE_WAIT(关闭等待)状态."),v("br"),r._v("\n3> A收到来自B的确认后,A进入FIN_WAIT_2(终止等待2)状态."),v("br"),r._v("\n4> 等待一会,服务端B也发完数据后,B会向A发送FIN连接释放报文段.B进入LAST_ACK(最后确认)状态."),v("br"),r._v("\n5> A收到B发送来的FIN=1报文后,A进入TIME_WAIT(时间等待)状态."),v("br"),r._v("\n6> "),v("font",{attrs:{color:"green"}},[r._v("A向B发送ACK=1的确认报文后,必须处于TIME_WAIT等待2MSL的时间后,A才会进入CLOSE状态.")]),v("br"),r._v("\n     具体来说是为了避免两种情况."),v("br"),r._v("\n     第一种,B长时间没有收到最后一次确认,B会再次向A发送FIN报文,A会重传最后一次的ACK报文"),v("br"),r._v("\n             为了B能准确无误的收到最后一次的ACK确认报文."),v("br"),r._v('\n     第二种,防止"已经失效的连接请求报文段"出现在本连接中.A在发送完最后一个ACK报文段后,'),v("br"),r._v("\n             再经过2MSL的时间,就可以使本连接持续的时间内所产生的所有报文段都从网络中消失."),v("br"),r._v("\n             这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段.."),v("br"),r._v("\n7> B只要收到来自A的确认后,服务端B直接关掉了这个连接..B进入CLOSE状态.."),v("br"),r._v("\n     可以发现,B进入CLOSE状态会比A早一些!!"),v("br"),r._v(" "),v("font",{attrs:{color:"gray"}},[r._v("Ps: MSL通常为2min; ")]),v("br"),r._v(" "),v("font",{attrs:{color:"brown"}},[r._v("敲黑板!")]),r._v(" "),v("font",{attrs:{color:"gray"}},[v("strong",[r._v("针对断连接,中间的两次为啥不能合二为一?")]),r._v(" S要等数据全部发给C后,才会发送FIN报文段.")])],1),r._v(" "),v("div",{staticClass:"language-tex line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-tex"}},[v("code",[r._v("qTCP协议的重点:\n\n"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[r._v("[")]),r._v("可靠性"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[r._v("]")]),r._v("\n不是说建立了双向通路就可靠,而是A发送的数据是拷贝一份沿着网络发送给B,待B接收到后,会回个ACK给A,意味着B告诉A收到数据啦,A才会将这份数据在内存中删除掉.. 若等一段时候,A没有得到ACK确定,会重传.. 尝试几次后都没得到,A就会认为B坏了..不会再发了. TCP这种保证数据可靠性的方式,对传输速率没有影响,但对资源是浪费了..因为A在等待B回复ACK的期间,数据一直在内存里放着..牺牲空间来换取可靠性.\n\n"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[r._v("[")]),r._v("三连四挥 各种状态"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[r._v("]")]),r._v("\n建立连接是三次,断连接是四次,因为前者没有数据在传,后者有数据在传!!\n建连接通常是s先启动后,C对S发起连接;断连接就没准了,C与S谁先发完谁先断.\n\n\n为啥需要三次握手建立连接,四次挥手断开连接.\nhttps://blog.csdn.net/LO_YUN/article/details/115541563\n")])]),r._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[r._v("1")]),v("br"),v("span",{staticClass:"line-number"},[r._v("2")]),v("br"),v("span",{staticClass:"line-number"},[r._v("3")]),v("br"),v("span",{staticClass:"line-number"},[r._v("4")]),v("br"),v("span",{staticClass:"line-number"},[r._v("5")]),v("br"),v("span",{staticClass:"line-number"},[r._v("6")]),v("br"),v("span",{staticClass:"line-number"},[r._v("7")]),v("br"),v("span",{staticClass:"line-number"},[r._v("8")]),v("br"),v("span",{staticClass:"line-number"},[r._v("9")]),v("br"),v("span",{staticClass:"line-number"},[r._v("10")]),v("br"),v("span",{staticClass:"line-number"},[r._v("11")]),v("br"),v("span",{staticClass:"line-number"},[r._v("12")]),v("br")])]),v("hr")])}),[],!1,null,null,null);t.default=s.exports},468:function(r,t,_){r.exports=_.p+"assets/img/8.8c7d30f8.gif"},469:function(r,t,_){r.exports=_.p+"assets/img/7.2a1d6d2a.png"},470:function(r,t,_){r.exports=_.p+"assets/img/27.29d79bc5.gif"},471:function(r,t,_){r.exports=_.p+"assets/img/20.bcd900e9.png"},472:function(r,t,_){r.exports=_.p+"assets/img/9.97231914.png"},473:function(r,t,_){r.exports=_.p+"assets/img/11.b4069bf3.png"}}]);